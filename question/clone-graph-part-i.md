# 克隆图 第一部

http://leetcode.com/2012/05/clone-graph-part-i.html

> 克隆一个图。输入的是一个节点指针。返回的是克隆图的节点指针。

一个图定义如下：
```
struct Node {
    std::vector neighbors;
}
```

## 提示
遍历一个图有两种方法。你还记得吗？你能说出一个图是有向图还是无向图吗？

## 解法
遍历一个图主要有两种方法：广度优先和深度优先。让我们先来尝试一下广度优先解法，需要一个队列。关于深度优先解法，请看克隆图第二部。

广度优先遍历是如何工作的呢？简单，当我们从队列中取出一个节点，我们拷贝该节点的邻居，并把邻居压入队列。

一个直接了当的广度优先遍历似乎可以工作了。但是依旧遗漏了某些细节。比如，我们如何连接克隆图的节点？

在我们继续之前，我们首先需要确认该图是否是有向的。如果你注意到之前是如何定义节点的，很明显该图是有向的。为什么？

比如，A可以有一个邻居B。所以，我们可以从A遍历到B。一个无向图说明B总是可以遍历回A。在这里是这样的吗？不是的，因为B是否可以遍历回A取决与B是否有个邻居是A。

B能遍历回A说明该图可能包含一个环。你必须特别注意处理该情况。设想一下你笔试的时候忘记了考虑该情况，之后被你的面试官指出你的代码中存在一个死循环，讨厌！

让我们用下面的例子来进一步分析：

![ScreenShot](https://raw.github.com/xiangzhai/leetcode/master/image/graph.png)

假设该图的起点是A。首先，你生成节点A的一个副本A2，然后发现A只有一个邻居B。你生成B的一个副本B2，然后通过压入B2成为A2的邻居来连接A2->B2。接下来，你发现B有一个邻居A，你已经生成过A的副本。这里，我们必须注意不能重复生成A的副本，而是通过压入A2作为B2的邻居来连接B2->A2。但是，我们怎么知道某个节点已经有副本了呢？

简单，我们可以使用一个HASH表！当我们拷贝了一个节点，我们把它插入到表里。如果我们之后发现某个节点的邻居已经在表里，我们就不能生成该邻居的副本，而是压入该邻居的副本做为它的副本。所以，该HASH表需要存储KEY-VALUE映射，这里KEY是原图里的某个节点，而VALUE是该节点的副本。

我们就不在这里码代码了，请直接看 https://github.com/xiangzhai/leetcode/blob/master/src/clonegraph/clonegraph.cpp
