# 回文数

http://leetcode.com/2012/01/palindrome-number.html

> 确定一个整数是否是回文。不能使用额外的空间。

在之前的题目中（最长回文子字符串 第一部 第二部）我们讨论过在字符串中寻找最长回文的多种解法。在这道题里，我们讨论确定一个整数是否是回文。听起来容易？

## 提示
不要被忽悠了该题不容易解。还要注意约束条件不能使用额外空间。考虑通用的解法任何语言/平台都支持。也考虑什么情况下你的解法可能出错。

## 解法
首先，该题没有描述清楚负数是否属于回文。比如负数-1是否是回文？每个程序员必须在码代码之前弄清楚该题的所有需求。我们在这里讨论的，定义负数不是回文。

最直观的解法是首先将整数转换成字符串，那样就更加容易操作。虽然这种解法可以工作，但是它违反了不能使用额外空间的约束。（比如，你需要申请n个字符空间来存储反转后的整数字符串，n是整数的最大位数）我知道，这听上去是不合理的需求（尽管它只使用了很少的空间），但是大多数面试题都会有如此需求吧？

另一个解法是首先反转整数。如果原始整数等于反转后的整数，那么它肯定是回文。你可以反转整数如下所示：

```
int reverse(int num) 
{
    assert(num >= 0);   // 只考虑正整数
    int rev = 0;
    while (num != 0) {
        rev = rev * 10 + num % 10;
        num /= 10;
    }
    return rev;
}
```

这个看上去也能工作，但是你考虑到反转整数有可能溢出吗？如果溢出了，取决于编程语言（Java封装了溢出，但是C/C++就会段错误）。讨厌！

当然，我们可以返回比int（比如long long）存储空间更大的类型来防止溢出。但是，注意这也取决于编程语言，不是所有的编程语言都支持大数据类型。

我们可以构造一个更好的更加通用的解法。关键在于，我们必须按位比较。而且你知道只有两种方法，从中间开始或从两端开始比较。

从两端开始比较比较简单。首先，按位比较第一个和最后一个。如果它们不相等，它就不是回文。如果相等，从两端各砍掉一位，继续比较，直到按位比较完所有的数，你就可以得出结论它是回文。

获取、砍掉最后一位很简单。但是，如何使用通用方法砍掉第一位。我把这个问题留给你做个练习。请先思考你的解法，在偷看下面的。

```
bool isPalindrome(int x) 
{
    if (x < 0) 
        return false;
    int div = 1;
    while (x / div >= 10) 
        div *= 10;    
    while (x != 0) {
        int l = x / div;
        int r = x % 10;
        if (l != r) 
            return false;
        x = (x % div) / 10;
        div /= 100;
    }
    return true;
}
```

## 另一种解法
递归解法（如果额外的栈空间不算额外空间）非常简洁。

```
bool isPalindrome(int x, int &y) 
{
    if (x < 0) 
        return false;
    if (x == 0) 
        return true;
    if (isPalindrome(x / 10, y) && (x % 10 == y % 10)) {
        y /= 10;
        return true;
    } else {
        return false;
    }
}

bool isPalindrome(int x) 
{
    return isPalindrome(x, x);
}
```
