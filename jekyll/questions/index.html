---
layout: questions
title: 克隆图 第一部分
next_section: longest-palindromic-substring-part-ii
permalink: /home/
---

<div class="note info">
    <p>克隆一个图。输入的是一个Node指针。返回值是被克隆的图的Node指针。</p>

    <p>一个图的结构体定义如下：</p>
    {% highlight cpp %}
    struct Node {
        std::vector neighbors;
    }
    {% endhighlight %}
</div>

<div class="note">
    <p>有两种方法来遍历一个图。你还记得是哪<a href="http://zh.wikipedia.org/zh-cn/%E5%9B%BE%E9%81%8D%E5%8E%86" target="_blank">两种</a>吗？你能判断这个图是<a href="http://zh.wikipedia.org/zh-cn/%E5%9B%BE" target="_blank">有向图还是无向图</a>吗？</p>
</div>

<p><a href="http://leetcode.com/2012/05/clone-graph-part-i.html" target="_blank">leetcode.com提供的答案</a>：有两种方法来遍历一个图：广度优先、<a href="http://www.shendu.com" target="_blank">深度</a>优先。先尝试广度优先，需要一个队列。</p>

<p>广度优先的遍历是怎么鼓捣的？从队列里弹出一个节点，拷贝这个节点的全部邻居，再把这些邻居插入队列。</p>

<p>广度优先的遍历貌似可行。但是遗漏了某些细节。比如，我们如何连接克隆图的节点？</p>

<p>我们首先要确认图是否是有向的。如果你注意到Node是如何定义的，显而易见该图是有向图。为什么？</p>

<p>例如，A有个邻居B。那么，我们可以从A遍历到B。一个无向图意味着B可以遍历回到A。是真的吗？不，因为B是否能遍历回到A，取决于B有个邻居是A。</p>

<p>B可以遍历回到A意味着图可能包含一个环。必须谨慎处理这种情况。假如你完成了面试题但却忘了考虑这个情况，面试官随后就会指出你的代码中有一个死循环，讨厌～～～</p>

<p>举例分析如下：</p>

<img src="{{ site.url }}/img/simple_graph.png" alt="简单图">

<p>假设图的起点是A。首先，复制节点A(A2)，发现A只有一个邻居B。复制B(B2)，插入B2作为A2的邻居，连接了A2->B2。接下来，发现B有个邻居A，而A已经有个副本。这里，我们要注意不能再复制A，插入A2作为B2的邻居，连接B2->A2。但是，我们怎么知道一个节点已经被复制了呢？</p>

<p>简单，可以使用hash表！复制一个节点，就把它插入hash表。如果发现节点的某一个邻居已经在hash表里了，就不需要复制那个邻居，而是使用邻居的副本替代节点的副本。hash表存储key-value映射，key是原图里的节点，value是节点的副本。</p>

{% highlight cpp %}
typedef unordered_map<Node *, Node *> Map;
 
Node *clone(Node *graph) {
    if (!graph) return NULL;
 
    Map map;
    queue<Node *> q;
    q.push(graph);
 
    Node *graphCopy = new Node();
    map[graph] = graphCopy;
 
    while (!q.empty()) {
        Node *node = q.front();
        q.pop();
        int n = node->neighbors.size();
        for (int i = 0; i < n; i++) {
            Node *neighbor = node->neighbors[i];
            // 没有该副本
            if (map.find(neighbor) == map.end()) {
                Node *p = new Node();
                map[node]->neighbors.push_back(p);
                map[neighbor] = p;
                q.push(neighbor);
            } else {     // 副本已经存在
                map[node]->neighbors.push_back(map[neighbor]);
            }
        }
    }
 
    return graphCopy;
}
{% endhighlight %}

<div class="note info">                                                         
    <p>LeetCode.cn更希望提供真实的可编译运行的C++ 0x11<a href="https://raw.github.com/xiangzhai/leetcode/master/clonegraph/clonegraph.cpp" target="_blank">源代码</a></p>        
                                                                                
    <p>首先一个图的节点的结构体定义如下：</p>                                             
    {% highlight cpp %}                                                         
    template<typename T> class graph_node                                           
	{                                                                               
	public:                                                                         
    	graph_node() {}                                                             
    	graph_node(T data) :m_data(data) {}                                         
    	~graph_node() {}                                                            
                                                                                
	public:                                                                         
    	std::vector<graph_node<T>*> neighbors;                                      
    	T get_data() { return m_data; }                                             
                                                                                
	private:                                                                        
    	T m_data;                                                                   
	};                                                                          
    {% endhighlight %}                                                          
</div>

<p>一个图的节点不仅包含结构std::vector<graph_node<T>*> neighbors；同时也需要包含数据T m_data。这里使用template<typename T>模板类来支持多种数据类型。我们会为graph_node取个别名：</p>
{% highlight cpp %}
typedef graph_node<int> Node;
{% endhighlight %}

<p>LeetCode.com的原答案中没有考虑cleanup的事儿：</p>
{% highlight cpp %}
static void m_cleanup()                                                         
{                                                                               
    MapIter iter;                                                               
    int i;                                                                      
                                                                                
    for (iter = map.begin(); iter != map.end(); iter++)                         
    {                                                                           
        for (i = 0; i < (*iter).second->neighbors.size(); i++)                  
        {                                                                       
            delete (*iter).second->neighbors[i];                                
            (*iter).second->neighbors[i] = NULL;                                
        }                                                                       
    }                                                                           
                                                                                
    if (graphCopy)                                                              
    {                                                                           
        delete graphCopy;                                                       
        graphCopy = NULL;                                                       
    }                                                                           
}
{% endhighlight %}
