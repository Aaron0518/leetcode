---
layout: docs
title: 使用BlueZ用C语言开发蓝牙程序 
next_section: quickstart
permalink: /home/
---

<h2>选择一个通讯搭档</h2>

<p>一个简单的程序——识别附近的蓝牙设备。程序获取系统蓝牙资源，扫描附近的蓝牙设备
，然后查看设备的名称。</p>

<p>simplescan.c</p>
{% highlight c %}
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/hci.h>
#include <bluetooth/hci_lib.h>

int main(int argc, char *argv[])
{
    inquiry_info *ii = NULL;
    int max_rsp, num_rsp;
    int dev_id, sock, len, flags;
    int i;
    char addr[19] = {0};
    char name[248] = {0};

    dev_id = hci_get_route(NULL);
    sock = hci_open_dev(dev_id);
    if (dev_id < 0 || sock < 0) {
        perror("opening socket");
        exit(1);
    }

    len = 8;
    max_rsp = 255;
    flags = IREQ_CACHE_FLUSH;
    ii = (inquiry_info*)malloc(max_rsp * sizeof(inquiry_info));
    
    num_rsp = hci_inquiry(dev_id, len, max_rsp, NULL, &ii, flags);
    if (num_rsp < 0) 
        perror("hci_inquiry");

    for (i = 0; i < num_rsp; i++) {
        ba2str(&(ii+i)->bdaddr, addr);
        memset(name, 0, sizeof(name));
        if (hci_read_remote_name(sock, &(ii+i)->bdaddr, sizeof(name), 
            name, 0) < 0)
        strcpy(name, "[unknown]");
        printf("%s  %s\n", addr, name);
    }

    free(ii);
    ii = NULL;
    close(sock);
    sock = -1;

    return 0;
}
{% endhighlight %}

<h3>用scons编译</h3>

{% highlight python %}
env = Environment(CCFLAGS='-g')                                                 
env.ParseConfig('pkg-config --cflags --libs bluez')                             
                                                                                
env.Program('simplescan.c')
{% endhighlight %}

<p>$ scons</p>

<h3>解释</h3>

{% highlight c %}
typedef struct {
    uint8_t b[6];
} __attribute__((packed)) bdaddr_t;
{% endhighlight %}

<p>用来表示一个蓝牙设备地址的基本数据结构是bdaddr_t。所有BlueZ的蓝牙地址都存储
在bdaddr_t结构体中。BlueZ提供两个函数用来字符与bdaddr_t结构体的互相转换。</p>

{% highlight c %}
int str2ba(const char *str, bdaddr_t *ba);
int ba2str(const bdaddr_t *ba, char *str);
{% endhighlight %}

<p>str2ba将XX:XX:XX:XX:XX:XX格式的字符串转换成6字节的bdaddr_t，其中XX是十六进制
数，代表48位地址的8位。ba2str实现相反的功能。</p>

<p>本地蓝牙适配器用0开始的数字标识，当分配系统资源时，一个程序必须指定是哪一个
适配器在使用。通常的，只有一个适配器或者无所谓哪一个在用，所以传递NULL指针给
hci_get_route将获得第一个可使用的蓝牙适配器的资源。</p>

{% highlight c %}
int hci_get_route(bdaddr_t *bdaddr);
int hci_open_dev(int dev_id);
{% endhighlight %}

Note    

<p>把设备号写死0不好，因为第一个适配器不一定id是0。比如，如果系统有两个适配器，
而且第一个适配器（id 0）禁用了，那么第一个可使用的适配器的id就是1。</p>

<p>如果当前有多个蓝牙适配器，选择地址为01:23:45:67:89:AB的适配器，传递char *
指针地址给hci_devid，在hci_get_route中使用它的返回值。</p>

{% highlight c %}
int dev_id = hci_devid("01:23:45:67:89:AB");
{% endhighlight %}

Most Bluetooth operations require the use of an open socket. hci_open_dev is a convenience function that opens a Bluetooth socket with the specified resource number [2]. To be clear, the socket opened by hci_open_dev represents a connection to the microcontroller on the specified local Bluetooth adapter, and not a connection to a remote Bluetooth device. Performing low level Bluetooth operations involves sending commands directly to the microcontroller with this socket, and Section 4.5 discusses this in greater detail.

After choosing the local Bluetooth adapter to use and allocating system resources, the program is ready to scan for nearby Bluetooth devices. In the example, hci_inquiry performs a Bluetooth device discovery and returns a list of detected devices and some basic information about them in the variable ii. On error, it returns -1 and sets errno accordingly.

{% highlight c linenos %}
int hci_inquiry(int dev_id, int len, int max_rsp, const uint8_t *lap, 
                inquiry_info **ii, long flags);
{% endhighlight %}

hci_inquiry is one of the few functions that requires the use of a resource number instead of an open socket, so we use the dev_id returned by hci_get_route. The inquiry lasts for at most 1.28 * len seconds, and at most max_rsp devices will be returned in the output parameter ii, which must be large enough to accommodate max_rsp results. We suggest using a max_rsp of 255 for a standard 10.24 second inquiry.

If flags is set to IREQ_CACHE_FLUSH, then the cache of previously detected devices is flushed before performing the current inquiry. Otherwise, if flags is set to 0, then the results of previous inquiries may be returned, even if the devices aren't in range anymore.

The inquiry_info structure is defined as

{% highlight c %}
typedef struct {
    bdaddr_t    bdaddr;
    uint8_t     pscan_rep_mode;
    uint8_t     pscan_period_mode;
    uint8_t     pscan_mode;
    uint8_t     dev_class[3];
    uint16_t    clock_offset;
} __attribute__ ((packed)) inquiry_info;
{% endhighlight %}

For the most part, only the first entry - the bdaddr field, which gives the address of the detected device - is of any use. Occasionally, there may be a use for the dev_class field, which gives information about the type of device detected (i.e. if it's a printer, phone, desktop computer, etc.) and is described in the Bluetooth Assigned Numbers [3]. The rest of the fields are used for low level communication, and are not useful for most purposes. The interested reader can see the Bluetooth Core Specification [4] for more details.

Once a list of nearby Bluetooth devices and their addresses has been found, the program determines the user-friendly names associated with those addresses and presents them to the user. The hci_read_remote_name function is used for this purpose.

{% highlight c linenos %}
int hci_read_remote_name(int sock, const bdaddr_t *ba, int len, 
                         char *name, int timeout)
{% endhighlight %}

hci_read_remote_name tries for at most timeout milliseconds to use the socket sock to query the user-friendly name of the device with Bluetooth address ba. On success, hci_read_remote_name returns 0 and copies at most the first len bytes of the device's user-friendly name into name. On failure, it returns -1 and sets errno accordingly.
Notes
[1] 

http://www.bluez.org/lists.html
[2] 

for the curious, it makes a call to socket(AF_BLUETOOTH, SOCK_RAW, BTPROTO_HCI), followed by a call to bind with the specified resource number.
[3] 

https://www.bluetooth.org/foundry/assignnumb/document/baseband
[4] 

http://www.bluetooth.org/spec
